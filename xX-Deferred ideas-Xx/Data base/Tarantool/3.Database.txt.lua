-- 3.1. Document data model
-- If you tried out the Starting Tarantool and making your first database exercise from the last chapter, then your database looks like this:
--
--	+--------------------------------------------+
--	|                                            |
--	| SPACE 'tester'                             |
--	| +----------------------------------------+ |
--	| |                                        | |
--	| | TUPLE SET 'tester'                     | |
--	| | +-----------------------------------+  | |
--	| | | Tuple: [ 1 ]                      |  | |
--	| | | Tuple: [ 2, 'Music' ]             |  | |
--	| | | Tuple: [ 3, 'length', 93 ]        |  | |
--	| | +-----------------------------------+  | |
--	| |                                        | |
--	| | INDEX 'primary'                        | |
--	| | +-----------------------------------+  | |
--	| | | Key: 1                            |  | |
--	| | | Key: 2                            |  | |
--	| | | Key: 3                            |  | |
--	| | +-----------------------------------+  | |
--	| |                                        | |
--	| +----------------------------------------+ |
--	+--------------------------------------------+


-- 3.1.3. Index
-- Индекс может быть многоэлементным, то есть, пользователь может решить, что значение ключа индекса берется из двух или более полей в кортеже, в любом порядке. Индекс может быть уникальным, то есть, пользователь может решить - недопустимо чтобы одно и то же значение ключа встречалось дважды. Индекс может иметь один из четырех типов: HASH - является самым быстрым и использует наименьшее количество памяти, но должен быть уникальным, TREE - допускает поиск по элементам ключа и сортирует результаты, BITSET - может быть хорош для поисковых запросов, которые содержат '=' и множественные И условия, и RTREE - для пространственных координат. Первый индекс определяется, как "первичный ключ" и должен быть уникальным; все остальные называются "вторичными" индексами.
-- Определение индекса может включать в себя идентификаторы полей кортежей и их типы. Допустимые типы для индексированных полей: NUM (unsigned integer between 0 and 18,446,744,073,709,551,615), или INT (signed integer between -9,223,372,036,854,775,808 and 9,223,372,036,854,775,807), или NUMBER (unsigned integer or signed integer or floating-point value), или STR (string, any sequence of octets), или SCALAR (boolean or number or string), или ARRAY (a series of numbers for use with RTREE indexes). Смотрите пример, содержащийся в запросе:
tarantool> i = s:create_index('primary', {type = 'hash', parts = {1, 'NUM'}})


-- 3.1.4. Data types
-- Tarantool can work with numbers, strings, booleans, tables, and userdata.
--	General type	Specific type 	What Lua type()|would return 	Example
--	scalar 			number 			"number" 						12345
--	scalar 			string 			"string" 						'A B C'
--	scalar 			boolean 		"boolean" 						true
--	scalar 			nil 			"nil" 							nil
--	compound 		Lua table 		"table" 						table: 0x410f8b10
--	compound 		tuple 			"Userdata" 						12345: {'A B C'}


-- 3.1.5. Operations
-- Основные операции: пять операций изменения данных (insert, update, upsert, delete, replace), и операция поиска данных (select). Также есть незначительные операции, такие как "пинг", которые используются только с бинарным протоколом. Кроме того, существует операции итерации по индексам, которые могут быть использованы только в Lua коде. (Индекс итераторы для обхода индексирует один ключ в то время, пользуясь функциями, которые являются специфическими для типа индекса, например, вычисления логических выражений при прохождении индексов BitSet, или идти в порядке убывания индексов при прохождении дерева.)
-- Шесть примеров основных операций:

-- Добавим новый кортеж в набор кортежей тестера.
-- The first field, field[1], will be 999 (type is NUM).
-- The second field, field[2], will be 'Taranto' (type is STR).
tarantool> box.space.tester:insert{999, 'Taranto'}

-- Обновление кортежа, изменение поля field[2].
-- Параметр "{999}", имеющее значение для поиска
-- по полю индекса с первичным ключом, является обязательным, 
-- так как update() запросы всегда должны иметь параметр 
-- определяющий первичный ключ, которым в данном случае является field[1].
-- параметр "{{'=', 2, 'Tarantino'}}" указывает, что присваивание нового 
-- значения произойдет в field[2] с новым значением.
tarantool> box.space.tester:update({999}, {{'=', 2, 'Tarantino'}})

-- Обновление кортежа, изменение поля field[2] еще раз.
-- Синтаксис upsert похож на синтаксис update,
-- но возвращаемое значение будет отличаться.
tarantool> box.space.tester:upsert({999}, {{'=', 2, 'Tarantism'}})

-- Заменить кортеж, добавив новое поле.
-- Это также возможно с update() запросом, но
-- the update() запрос, как правило, более сложный.
tarantool> box.space.tester:replace{999, 'Tarantella', 'Tarantula'}

-- Получить кортеж.
-- Параметр "{999}" по-прежнему является обязательным, хотя он не обязан быть первичным ключом.
tarantool> box.space.tester:select{999}

-- Удалить кортеж.
-- Снова первый параметр обязан быть первичным ключом.
tarantool> box.space.tester:delete{999}


-- 3.1.7. Data manipulation
-- Основными запросами манипулирующими данными являются: insert, replace, update, upsert, delete, select. Все они являются частью библиотеки Box. Большинство из них возвращают данные. Обычно оба входы и выходы представляют собой таблицы Lua.
-- Синтаксис Lua для функций работающих с данными может изменяться. Ниже приведены примеры вариаций некоторых запросов; такие же правила существуют и для других функций (data-manipulation). Каждый из примеров делает то же самое: выбирает кортеж из набора в пространстве Тестер, где значение поля первичного ключа равно 1. Для примеров, существует предположение, что числовой идентификатор "тестера" является 512, который работает в нашем случае примера песочницы.
-- Во-первых, имеется пять примеров ссылок на объекты:

-- #1 package . sub-package . name
tarantool> box.space.tester:select{1}

-- #2 replace name with a literal in square brackets
tarantool> box.space['tester']:select{1}

-- #3 replace name with a numeric id in square brackets
tarantool> box.space[512]:select{1}

-- #4 use a variable instead of a literal for the name
tarantool> variable = 'tester'
tarantool> box.space[variable]:select{1}

-- #5 use a variable for the entire object reference
tarantool> s = box.space.tester
tarantool> s:select{1}

-- Более поздние примеры в данном руководстве, как правило, имеют форму "box.space.tester:"(#1); тем не менее, это вопрос предпочтения пользователя и существуют все вариации в дикой природе.
-- Более поздние описания в этом руководстве будут использовать синтаксис "space_object:" для ссылок на объекты пространств, как в вышеупомянутых примерах, и "index_object:" для ссылок на объекты индексов (например box.space.tester.index.primary:).
-- Тогда есть семь вариантов параметров:

-- #1
tarantool> box.space.tester:select{1}

-- #2
tarantool> box.space.tester:select({1})

-- #3
tarantool> box.space.tester:select(1)

-- #4
tarantool> box.space.tester.select(box.space.tester,1)

-- #5
tarantool> box.space.tester:select({1},{iterator='EQ'})

-- #6
tarantool> variable = 1
tarantool> box.space.tester:select{variable}

-- #7
tarantool> variable = {1}
tarantool> box.space.tester:select(variable)


-- 3.2. Packages of the box library

-- Содержимое библиотеки Box можно проверить во время выполнения с box, без аргументов. Пакеты внутри библиотеки box: box.schema, box.tuple, box.space, box.index, box.cfg, box.info, box.slab, box.stat. Каждый пакет содержит одну или несколько функций Lua. Несколько пакетов содержат элементы, также и функции. Эти функции позволяют определять данные (создать альтер падение), манипулировать данными (insert delete update upsert select replace), и совершать самоанализ (осматривая содержимое пространств, доступа к конфигурации сервера).
-- Факторы сложности, которые могут повлиять на функции манипулирования данными в библиотеке Box:
-- Размер индекса - Число ключей индекса совпадает с числом кортежей в наборе данных. Для индекса типа TREE, если есть несколько ключей, то время поиска будет больше, хотя, конечно, эффект не является линейным. Для индекса типа HASH, если есть несколько ключей, то использование оперативной памяти больше, но количество низкоуровневых шагов имеет тенденцию оставаться постоянным.
-- Тип индекса - Как правило, индекс HASH быстрее, чем индекс TREE, если число кортежей в коллекции данных больше единицы.
-- Количество доступных индексов - Обычно только один индекс доступен для извлечения одного кортежа. Но для обновления кортежа, должно быть N доступных, если набор кортежей имеет N различных индексов.
-- Количество доступных кортежей - Несколько запросов, например выбора, имеют возможность получить несколько кортежей. Этот фактор, как правило, менее важен, чем другие.
-- Настройки WAL -  Важный параметр для записи журнала wal_mode. Если настройки не влияют на запись или ее замедление, этот фактор не имеет значения. Если настройки вызывают ожидание записи при каждом запросе на изменение данных, чтобы записать на медленном устройстве, этот фактор является более важным, чем все остальные.

-- При обсуждении каждой функции манипулирующей данными будет примечание о том, какие факторы сложности могут повлиять на использование ресурсов функции.
