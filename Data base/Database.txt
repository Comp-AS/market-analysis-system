3.1. Document data model

If you tried out the Starting Tarantool and making your first database exercise from the last chapter, then your database looks like this:

+--------------------------------------------+
|                                            |
| SPACE 'tester'                             |
| +----------------------------------------+ |
| |                                        | |
| | TUPLE SET 'tester'                     | |
| | +-----------------------------------+  | |
| | | Tuple: [ 1 ]                      |  | |
| | | Tuple: [ 2, 'Music' ]             |  | |
| | | Tuple: [ 3, 'length', 93 ]        |  | |
| | +-----------------------------------+  | |
| |                                        | |
| | INDEX 'primary'                        | |
| | +-----------------------------------+  | |
| | | Key: 1                            |  | |
| | | Key: 2                            |  | |
| | | Key: 3                            |  | |
| | +-----------------------------------+  | |
| |                                        | |
| +----------------------------------------+ |
+--------------------------------------------+


3.1.3. Index

An index may be multi-part, that is, the user can declare that an index key value is taken from two or more fields in the tuple, in any order. An index may be unique, that is, the user can declare that it would be illegal to have the same key value twice. An index may have one of four types: HASH which is fastest and uses the least memory but must be unique, TREE which allows partial-key searching and ordered results, BITSET which can be good for searches that contain '=' and multiple ANDed conditions, and RTREE for spatial coordinates. The first index is called the “primary key” index and it must be unique; all other indexes are called “secondary” indexes.

An index definition may include identifiers of tuple fields and their expected types. The allowed types for indexed fields are NUM (unsigned integer between 0 and 18,446,744,073,709,551,615), or INT (signed integer between -9,223,372,036,854,775,808 and 9,223,372,036,854,775,807), or NUMBER (unsigned integer or signed integer or floating-point value), or STR (string, any sequence of octets), or SCALAR (boolean or number or string), or ARRAY (a series of numbers for use with RTREE indexes). Take our example, which has the request:

tarantool> i = s:create_index('primary', {type = 'hash', parts = {1, 'NUM'}})


3.1.4. Data types

Tarantool can work with numbers, strings, booleans, tables, and userdata.

General type	Specific type 	What Lua type()|would return 	Example
scalar 			number 			"number" 						12345
scalar 			string 			"string" 						'A B C'
scalar 			boolean 		"boolean" 						true
scalar 			nil 			"nil" 							nil
compound 		Lua table 		"table" 						table: 0x410f8b10
compound 		tuple 			"Userdata" 						12345: {'A B C'}


3.1.5. Operations

The basic operations are: the five data-change operations (insert, update, upsert, delete, replace), and the data-retrieval operation (select). There are also minor operations like “ping” which can only be used with the binary protocol. Also, there are index iterator operations, which can only be used with Lua code. (Index iterators are for traversing indexes one key at a time, taking advantage of features that are specific to an index type, for example evaluating Boolean expressions when traversing BITSET indexes, or going in descending order when traversing TREE indexes.)

Six examples of basic operations:

-- Add a new tuple to tuple set tester.
-- The first field, field[1], will be 999 (type is NUM).
-- The second field, field[2], will be 'Taranto' (type is STR).
tarantool> box.space.tester:insert{999, 'Taranto'}

-- Update the tuple, changing field field[2].
-- The clause "{999}", which has the value to look up in
-- the index of the tuple's primary-key field, is mandatory
-- because update() requests must always have a clause that
-- specifies the primary key, which in this case is field[1].
-- The clause "{{'=', 2, 'Tarantino'}}" specifies that assignment
-- will happen to field[2] with the new value.
tarantool> box.space.tester:update({999}, {{'=', 2, 'Tarantino'}})

-- Upsert the tuple, changing field field[2] again.
-- The syntax of upsert is similar to the syntax of update,
-- but the return value will be different.
tarantool> box.space.tester:upsert({999}, {{'=', 2, 'Tarantism'}})

-- Replace the tuple, adding a new field.
-- This is also possible with the update() request but
-- the update() request is usually more complicated.
tarantool> box.space.tester:replace{999, 'Tarantella', 'Tarantula'}

-- Retrieve the tuple.
-- The clause "{999}" is still mandatory, although it does not have to
-- mention the primary key.
tarantool> box.space.tester:select{999}

-- Delete the tuple.
-- Once again the clause to identify the primary-key field is mandatory.
tarantool> box.space.tester:delete{999}


3.1.7. Data manipulation

The basic data-manipulation requests are: insert, replace, update, upsert, delete, select. All of them are part of the box library. Most of them may return data. Usually both inputs and outputs are Lua tables.

The Lua syntax for data-manipulation functions can vary. Here are examples of the variations with select requests; the same rules exist for the other data-manipulation functions. Every one of the examples does the same thing: select a tuple set from a space named tester where the primary-key field value equals 1. For the examples there is an assumption that the numeric id of 'tester' is 512, which happens to be the case in our sandbox example only.

First, there are five object reference variations:

-- #1 package . sub-package . name
tarantool> box.space.tester:select{1}
-- #2 replace name with a literal in square brackets
tarantool> box.space['tester']:select{1}
-- #3 replace name with a numeric id in square brackets
tarantool> box.space[512]:select{1}
-- #4 use a variable instead of a literal for the name
tarantool> variable = 'tester'
tarantool> box.space[variable]:select{1}
-- #5 use a variable for the entire object reference
tarantool> s = box.space.tester
tarantool> s:select{1}

Later examples in this manual will usually have the "box.space.tester:" form (#1); however, this is a matter of user preference and all the variations exist in the wild.

Later descriptions in this manual will use the syntax "space_object:" for references to objects which are spaces as in the above examples, and "index_object:" for references to objects which are indexes (for example box.space.tester.index.primary:).

Then, there are seven parameter variations:

-- #1
tarantool> box.space.tester:select{1}
-- #2
tarantool> box.space.tester:select({1})
-- #3
tarantool> box.space.tester:select(1)
-- #4
tarantool> box.space.tester.select(box.space.tester,1)
-- #5
tarantool> box.space.tester:select({1},{iterator='EQ'})
-- #6
tarantool> variable = 1
tarantool> box.space.tester:select{variable}
-- #7
tarantool> variable = {1}
tarantool> box.space.tester:select(variable)


3.1.8. Index operations

3.2. Packages of the box library

The contents of the box library can be inspected at runtime with box, with no arguments. The packages inside the box library are: box.schema, box.tuple, box.space, box.index, box.cfg, box.info, box.slab, box.stat. Every package contains one or more Lua functions. A few packages contain members as well as functions. The functions allow data definition (create alter drop), data manipulation (insert delete update upsert select replace), and introspection (inspecting contents of spaces, accessing server configuration).

Complexity Factors that may affect data manipulation functions in the box library
Index size 						The number of index keys is the same as the number of tuples in the data set. For a TREE index, if there are more keys then the lookup time will be greater, although of course the effect is not linear. For a HASH index, if there are more keys then there is more RAM use, but the number of low-level steps tends to remain constant.
Index type 						Typically a HASH index is faster than a TREE index if the number of tuples in the tuple set is greater than one.
Number of indexes accessed 		Ordinarily only one index is accessed to retrieve one tuple. But to update the tuple, there must be N accesses if the tuple set has N different indexes.
Number of tuples accessed 		A few requests, for example select, can retrieve multiple tuples. This factor is usually less important than the others.
WAL settings 					The important setting for the write-ahead log is wal_mode. If the setting causes no writing or delayed writing, this factor is unimportant. If the setting causes every data-change request to wait for writing to finish on a slow device, this factor is more important than all the others.

In the discussion of each data-manipulation function there will be a note about which Complexity Factors might affect the function's resource usage.
